\documentclass[12pt,a4paper,titlepage]{article}
%%%%%%%%%%%%%%%%%%%%导言区%%%%%%%%%%%%%%%
%%宏包设置
\usepackage[BoldFont]{xeCJK}
\usepackage[dvips]{graphicx}
\usepackage[colorlinks,linkcolor=red,anchorcolor=red,citecolor=red,urlcolor=blue]{hyperref}
\usepackage{verbatim}
\usepackage{threeparttable}
%\usepackage{nl}
%%字体设置
\setCJKmainfont[BoldFont=SimHei,ItalicFont=SimSun]{SimSun}
\setmainfont{Times New Roman}
\setCJKfamilyfont{ht}{SimHei}
%%页面设置
\addtolength{\hoffset}{-1cm}
\addtolength{\voffset}{-2cm}
\addtolength{\textheight}{4cm}
\addtolength{\textwidth}{2cm}
%%标题页
\title{NIOS II Linux Tutorial}
\author{作者:陈锋\\\\审校:邢岚\\\\Email:cfistalent@gmail.com\\\\重庆大学通信工程学院2401学习资料}
%%%%%%%%%%%%%%%%%%%%正文%%%%%%%%%%%%%%%
\begin{document}
\thispagestyle{empty}
\maketitle{}
%%%%%%%%%%%%%%%%%%%%前言%%%%%%%%%%%%%%%
\section{前言}
\setcounter{footnote}{0}
本文由\LaTeX{}构建.
%源代码在\href{https://github.com/cfistalent/NiosII\_Linux\_Tutorial}{https://github.com/cfistalent/NiosII\_Linux\_Tutorial}上.
%可通过\fbox{git clone git://github.com/cfistalent/NiosII\_Linux\_Tutorial.git}获取最新的源码.

这是一个\textbf{NIOS II Linux}开发的入门教程,拟包括以下几个部分:\footnote{随着编写计划的变化,可能会有增减.}
\begin{itemize}
\item 如何获取资源;
\item 介绍\textbf{NIOS II Linux}开发环境;
\item 一个完整的流程,创建硬件到配置内核;
\item 开发前需要了解的知识;
\item linux下普通应用程序开发;
%\item linux下驱动开发举例;
\item FTK应用程序开发;
\end{itemize}

%由于笔者本身水平有限,无法保证没有描述不当或笔误的存在,有什么问题可与我\href{mailto:cfistalent@gmail.com}{联系}.
%%%%%%%%%%%%%%%%%%%%如何获得相关资料%%%%%%%%%%%%%%%
\newpage{}
\section{如何获得相关资料}
\setcounter{footnote}{0}
\subsection{网站}
\begin{description}
\item[\href{http://www.nioswiki.com/Linux}{NiosWiki上Linux主页}] 这是nios linux内核开发包的发布主页.
上面包含如何下载内核开发包,如何进行第一次编译等工作.有相应文档提供下载.
\item[\href{http://www.nioswiki.com/OperatingSystems/UClinux}{NiosWiki上uClinux主页}] 这里包含的内容大多数都适用于Linux.
因此,在动手之前请把这两个页面仔细读一读.
\item[\href{http://www.alteraforum.com/forum/forumdisplay.php?f=37}{Altera论坛}] 这里提供了一个问题交流的地方,学习过程中
遇到的问题都可以在这里获得响应.不过要注意两点:{\CJKfamily{ht}首先确认你在wiki上找不到答案,其次有合格的英语表达能力}.
\item[\href{http://sopc.et.ntust.edu.tw/pipermail/nios2-dev/}{nios linux开发者邮件列表}] 这里是nios linux的真正发源地.每个月
都会有若干个bug在这里被修复,新的版本的内核被移植.时刻关注这里可以让你与开发者同步.
\item[\href{ftp://ftp.altera.com/up/pub/}{Altera官方FTP}] 这里面资源很丰富,Altera FPGA的开发资料,Altera大学IP等等.
\item[\href{http://www.cnblogs.com/oomusou/}{一个台湾工程师的博客}] FPGA,特别是DE2和DE2-70的资源很丰富.
\item[\href{http://www.terasic.com/downloads/cd-rom/}{友晶公司的CD资源FTP}] 包含友晶公司各种开发板附带的CD资料.需要在友晶官网注册.
\end{description}
\subsection{书籍}
\begin{description}
\item[\href{http://www.amazon.cn/mn/detailApp/ref=sr\_1\_1?\_encoding=UTF8&s=books&qid=1291516849&asin=B001EJNTCC&sr=8-1}{SOPC嵌入式系统基础教程}] 介绍SOPC基础知识.是Altera官方文档的中文翻译版.有能力的同学可以直接看\href{http://www.altera.com.cn/literature/lit-nio2.jsp}{官方文档}.
\item[\href{http://www.amazon.cn/Nios-2\%E8\%BD\%AF\%E4\%BB\%B6\%E6\%9E\%B6\%E6\%9E\%84\%E8\%A7\%A3\%E6\%9E\%90-\%E8\%94\%A1\%E4\%BC\%9F\%E7\%BA\%B2/dp/B0011Y1VXO/ref=pd\_sim\_b\_2}{Nios2软件架构解析}] 将Altera的Nios2软件架构分析的很透彻,尽管针对的是6.0版本依然很有用.
\item[\href{http://www.amazon.cn/mn/detailApp/ref=sr\_1\_1?\_encoding=UTF8&s=books&qid=1291517188&asin=B004A7L87I&sr=1-1}
{Linux设备驱动开发详解}] 宋宝华老师的书,针对Linux驱动开发做了详尽的介绍.
\item[\href{http://www.amazon.cn/mn/detailApp/ref=sr\_1\_1?\_encoding=UTF8&s=books&qid=1291517330&asin=B003Q97NPC&sr=1-1}{Linux程序设计}]
 介绍Linux应用程序开发的好书.
\end{description}
%%%%%%%%%%%%%%%%%%%%构建开发环境%%%%%%%%%%%%%%%
\newpage{}
\section{构建开发环境}
\setcounter{footnote}{0}
2009年9月,nioswiki社区推出基于NIOS II处理器的linux内核开发包,为开发者提供一种新的系统方案.

使用\textbf{NIOS II Linux}开发需要搭建硬件和软件环境.目前已知的开发环境有两类:
\begin{table}[!hbtp]
\centering
\begin{tabular}{|l|p{0.68\textwidth}|}
\hline
完全在linux下开发 & 在linux下安装linux版本的Quartus II和NiosII IDE开发工具,同时安装nios-linux内核开发包.
据我所知目前只有\textbf{Ubuntu9.04}可以兼容,Ubuntu9.10及以上版本暂时不支持.\footnote{不支持的原因是nios2-download脚本在Ubuntu9.10及
以上版本中部分无法执行,而官方推荐的Redhat企业版和Fedora等均可配置}\\
\hline
WindowsXP+Linux虚拟机 & 这种方案更适合大多数平时工作在Windows环境下的开发者.本文接下来将介绍这种方案的配置.\footnote{由于在linux下
的usb-blaster驱动比windows下性能要相对差些,当构建的系统选择以JTAG-UART作为终端时,在linux环境下的"nios2-terminal"命令会导致系统阻塞,此时
我更倾向于使用本方案}\\
\hline
\end{tabular}
\caption{开发环境\label{dev_env}}
\end{table}
%%%3.1
\subsection{硬件环境}
首先需要在Windows上安装Quartus II和相应版本的NiosII IDE.本文使用是9.0版本.因此大于等于该版本都应该没有问题.
安装过程这里不赘述,有问题请自行查阅相关文档.但是安装的版本{\CJKfamily{ht}需要有lisence支持}.
%%%3.2
\subsection{软件环境}
linux内核驱动和应用程序的开发需要在类Unix操作系统下进行,最普遍的就是Linux操作系统.这里我们选择流行程度最高的Ubuntu操作系统作为开发平台.

首先我们要安装一款虚拟机软件\footnote{Windows下有Vmware,Virtual Box等}.通过该软件创建虚拟机并安装Ubuntu.安装好的虚拟机系统要满足两个要求:
\begin{itemize}
\item 能够连接互联网,下载内核开发所需的文件;
\item 能够与宿主机(Windows)交换文件.宿主机下生成的头文件要传入虚拟机中交给内核开发包使用,而虚拟机下生成的内核可执行文件要
在window下通过nios shell下载;
\end{itemize}

我们以Virtual Box为例说明如何操作\footnote{使用Vmware等只要满足上面两个条件同样可以搭建开发环境}.
%%%3.2.1
\subsubsection{虚拟机安装Ubuntu并做相关设置}
创建虚拟机之前,本地电脑上需要准备如下内容:
\begin{itemize}
\item Ubuntu安装光盘或ISO镜像文件;
\item 已安装好Virtual Box软件;
\item 足够的硬盘空间(14G左右);
\end{itemize}

在Virtual Box主页面菜单上选择\fbox{控制-->新建},操作系统类型选择\textbf{Linux},版本选择\textbf{Ubuntu},如图\ref{f_create_vb1}所示.
\begin{figure}[!bthp]
\centering\includegraphics[width=1\textwidth]{pic/f_create_vb1.eps}
\caption{创建虚拟机:整体设定\label{f_create_vb1}}
\end{figure}
内存选择为当前系统内存一半略少,尽量发挥系统性能.硬盘选择"创建新的虚拟硬盘"并选择"固定大小"\footnote{相对于动态增长,
固定大小使得虚拟机运行速度更快}.硬盘大小至少10G,以免内核开发包在虚拟机中解压缩后空间不够,{\CJKfamily{ht}注意,默认虚拟硬盘保存在系统盘中,
请将位置改到有足够空间的磁盘上}.硬盘创建完成后确定即可.

到现在为止,虚拟机已经创建完毕.但是当前的虚拟机内没有任何系统,甚至连分区都没有,此时需要通过光驱安装操作系统.本文使用ISO镜像
文件进行安装.

在没有运行虚拟机的情况下,点击\fbox{设置}图标,右侧找到"介质"一栏,对ISO进行注册.如图\ref{iso0},\ref{iso1}和\ref{iso2}所示.
\begin{figure}[!bthp]
\centering
\includegraphics[width=0.8\textwidth,scale=0.8]{pic/f_vb_setting_iso.eps}
\caption{设置ISO\label{iso0}}
\includegraphics[width=0.8\textwidth,scale=0.8]{pic/f_vb_setting_iso_register.eps}
\caption{设置ISO\label{iso1}}
\end{figure}
\begin{figure}[!bthp]
\centering
\includegraphics[width=0.8\textwidth,scale=0.8]{pic/f_vb_setting_iso_set.eps}
\caption{设置ISO\label{iso2}}
\end{figure}

之后运行虚拟机,系统就会从ISO进行引导,进而安装Ubuntu系统.过程略.

安装完成后.若宿主机能够访问互联网,则虚拟机也能访问互联网.剩下一个问题就是共享文件夹的设置.在设置之前,需要先安装Virtual Box提供的
增强工具包.在运行虚拟机的界面上选择\fbox{设备-->安装增强功能}.此时在虚拟机的桌面上就会出现一个光盘.打开终端\footnote{Alt+F2调出运行
窗口,输入\fbox{gnome-terminal}回车即可调出终端}.在终端中输入如下命令\footnote{下文中没有特别说明,运行的命令都将是在终端中}:
\begin{verse}
cd /media/cdrom\\sudo ./VBoxLinuxAdditions-x86.run \#若本地PC是amd64位架构,就运行VBoxLinuxAdditions-amd64.run\\输入管理员密码
\end{verse}
等待安装过程结束,关闭虚拟机{\CJKfamily{ht}(注意,这里一定要先关闭虚拟机)}.然后在\fbox{设置}中右侧找到"数据空间",添加一个在宿主机上已经存在的文件夹作为共享目的地.如图\ref{f_sf}所示.
启动虚拟机,终端中输入如下命令:
\begin{verse}
mkdir -p /home/<你的用户名>/Desktop/VBS \#在虚拟机中创建一个文件夹\\sudo mount -t vboxsf <宿主机中共享文件夹名称> 
/home/<你的用户名>/Desktop/VBS
\end{verse}
经过这番设置后,共享文件夹就设置成功了.但是,重启后设置将会失效,为使启动后系统自动处理共享文件夹,需进行如下配置.
\begin{verse}\label{cmd0}
sudo gedit /etc/fstab\\在打开的文件中添加一行" VBoxSharedFolder  /home/<你的用户名>/Desktop/VBS/  vboxsf  defaults 0 0"
\end{verse}
\begin{figure}[!bthp]
\centering
\includegraphics[width=0.8\textwidth,scale=0.8]{pic/f_vb_setting_sf.eps}
\caption{共享空间设置\label{f_sf}}
\end{figure}
%%%3.2.2
\subsubsection{内核开发包安装设置}
在安装内核开发包之前,要先安装一些基本的软件包:
\begin{verse}
sudo apt-get install git-core git-doc automake libtool enca ncurses-dev pax-utils
\end{verse}

将我提供的内核开发包\footnote{nios2-linux\_CF.tgz}拷贝到{\CJKfamily{ht}宿主机}的共享文件夹下,在{\CJKfamily{ht}虚拟机终端}运行如下命令:
\begin{verse}
cd /\\sudo chown <你的用户名,在这里,是bearchen:/> opt/\\mkdir NiosIILinux\\cd /opt/NiosIILinux/\\
tar -zxvf /home/<你的用户名>/Desktop/VBS/<内核开发包名称>
\end{verse}
我们将把内核开发不包安装在/opt目录下,前两个命令的目的是修改opt的所有者,方便之后运行命令.第三个命令则是我的内核开发包历史遗留问题.
第四个命令将内核解压缩到/opt/NiosIILinux/目录下.

{\CJKfamily{ht}注意,接下来的操作比起从官方网站下载的开发包要少一道步骤,就是将源码从git仓库中导出.因为我提供的源码包已经导出相关源码.}
接着安装内核开发所需的工具,包括gcc编译器等(其实就是将工具程序所在文件夹注册到系统环境变量中):
\begin{verse}
gedit ~/.bashrc\\在打开的文件中最后添加一行"export PATH=\$PATH:/opt/NiosIILinux/nios2-linux/toolchain-mmu/x86-linux2/bin"保存修改\\
source ~/.bashrc \#更新环境变量
\end{verse}
通过以上操作,内核开发的软件环境已经搭建完毕.为了测试当前是否搭建成功.可做如下操作:
\begin{enumerate}
\item 运行以下命令:
\begin{verse}
cd /opt/NiosIILinux/nios2-linux/uClinux-dist/\\make clean\\make menuconfig
\end{verse}
在打开的界面中\footnote{这是内核的配置菜单,在这个菜单中,Enter表示进入下一层,ESC两次表示退回上一层或者退出,SPACE表示修改选项状态}
选择"Kernel/Library/Defaults Selection--->"进入.选中"Default all settings(lose changes)".退出保存.对遇到的所有提问选择'N'.
\item 再次运行\fbox{make menuconfig}.进入"Kernel/Library/Defaults Selection--->".选中"Customize Kernel Settings".退出保存.
\item 在新弹出的配置窗口,进入"Device driver--->Network device support--->Ethernet(10 or 100mbit)--->"将"Altera Triple Speed Ethernet 
MAC Support(SLS)"选项取消.退出保存.
\item 运行以下命令\footnote{rc是linux内核启动后会自动执行的脚本文件,
可以通过他人为设置开机后自动运行的命令序列.这里设置为空,避免之后编译出的内核运行时出现不必要的现象.}:
\begin{verse}cd /opt/NiosIILinux/nios2-linux/uClinux-dist/vendors/Altera/common/\\echo > rc\end{verse}
\item 运行\fbox{make}.若接下来的过程没有错误.恭喜你.整个环境已经配置成功.
\end{enumerate}
%%%3.3
\subsection{体验NIOS II Linux}
如果你手头上正好有一块DE2-70开发板,则可以通过以下方式体验一下linux在nios处理器上运行的感觉.
\begin{enumerate}
\item 找到本文附带的文件夹中的两个文件"Starter\_Hardware.sof"和"Starter\_Kernel.gz".将他们拷贝到同一个文件夹下.
\item 运行nios shell.如图\ref{ns}所示.
\item 将DE2-70的电源和usb-blaster连接好.上电.
\item 在nios shell下进入刚才保存两个文件的目录.{\CJKfamily{ht}运行命令}\footnote{注意,这里是在宿主机的nios shell下输入命令}:
\begin{verse}
nios2-config-sof Starter\_Hardware.sof\ {}\ {}\&\&\ {}\ {}nios2-download -g Starter\_Kernel.gz\ {}\ {}\&\&\ {}\ {}nios2-terminal
\end{verse}
在nios shell上打印一堆信息后将看到类似终端的命令提示符.
若一切正常,此时的nios shell将作为开发板上运行的linux内核的终端与用户交互,你可以尝试输入命令获得响应.
\end{enumerate}
\begin{figure}[!htbp]
\centering
\includegraphics[width=0.75\textwidth,scale=0.75]{pic/f_shell_and_icon.eps}
\caption{Nios Shell图标和运行界面\label{ns}}
\end{figure}
%%%%%%%%%%%%%%%%%%%%走一遍流程%%%%%%%%%%%%%%%
\newpage{}
\section{第一个工程}
\setcounter{footnote}{0}
阅读本节内容的前提是读者已了解Quartus II和SOPC Builder的使用方法.否则请自行学习相关内容.

本节通过一个简单工程介绍整个设计流程.使用的硬件是\textit{DE2-70}\footnote{使用其他开发板一样可以完成本节内容,只需要
满足NiosII Linux开发的硬件最低要求}.整个过程包括但不限于:{\CJKfamily{ht}SOPC构建,顶层模块设计及管脚分配,linux内核
简单配置,下载运行}.
%%%4.1
\subsection{硬件设计}
构建的片上系统必须满足以下几个硬性条件,才能够运行linux内核和应用程序:
\begin{itemize}
\item FPGA芯片至少是Cyclone\footnote{这是基于当前开发社区提供资料的推测};
\item cpu类型至少是标准型(s),快速型(f)更佳;
\item 内存至少为8MB;
\item 必须有一个全功能定时器外设(timer),定时时间为10ms;
\item 必须有一个linux内核与外界交互的终端.一般为JTAG-UART或者UART;
\end{itemize}

\begin{enumerate}
\item 使用Quartus II的工程创建向导新建一个工程\footnote{本工程也存在于本文附加材料中,名为Nios2\_Linux\_C4.rar}.
启动SOPC Builder\footnote{{\CJKfamily{ht}接下来所有组件的设置,对没有提到的参数,一律为默认设置}},添加CPU,
{\CJKfamily{ht}无视错误信息},先保存.添加一个SDRAM Controller.存储器设置内容\footnote{相关信息根据\textit{DE2-70}开发板上SDRAM
参数填写.其他开发板请查阅相应SDRAM数据手册}:
\begin{table}[!bhtp]
\centering
\begin{tabular}{|c|c|c|c|c|c|}
\hline
Presets & Data Width & Chip select & Banks & Row & Column \\
\hline
Custom & 16 & 1 & 4 & 13 & 9\\
\hline
\end{tabular}
\caption{SDRAM Controller:Memory Profile}
\end{table}
\begin{table}[!bhtp]
\centering
\begin{tabular}{|l|c|}\hline
CAS latency cycles & 3\\\hline
Initialization refresh cycles & 2\\\hline
Issue one refresh command every & 7.8125 us\\\hline
Delay after powerup,before initialization & 200us\\\hline
Duration of refresh command(t\_rfc) & 70ns\\\hline
Duration of precharge command(t\_rp) & 20ns\\\hline
ACTIVE to READ or WRITE delay(t\_rcd) & 20ns\\\hline
Access time(t\_ac) & 5.5ns\\\hline
Write recovery time(t\_wr,no auto precharge) & 14ns\\\hline
\end{tabular}
\caption{SDRAM Controller:Timing}
\end{table}
\\保存为默认名称\textbf{"sdram\_0"}.
\item 为了使用CPU的MMU功能,需要添加一个onchip memory,需要配置的内容:类型为\textbf{RAM},\textbf{Dual-port access},
内存大小\textbf{1024 Bytes}.其他配置默认.名称没有指定,只要有意义即可.
\item 打开CPU配置界面,Reset Vector和Exception Vector都选为\textbf{sdram\_0}.Exception Vector的偏移地址选为\textbf{0x20}.
钩选\textbf{"Include MMU"},Fast TLB Exception Vector选为刚才添加的onchip memory.偏移量为\textbf{0}.在CPU的"Caches and Memory interfaces"
选项卡中,钩选\textbf{"Include tightly coupled instruction master port(s)"}和
\textbf{"Include tightly coupled data master port(s)"}.在"JTAG Debug Module"选项卡中,
将JTAG选为\textbf{level 2}.其余选项均默认.确定退出CPU设置.对cpu和sdram controller以及onchip memory
作图\ref{f_cpu_sdram_tcm}方式连接.
\begin{figure}[!bhtp]
\centering
\includegraphics[width=0.6\textwidth]{pic/f_sopc_cpu_tcm_sdram.eps}
\caption{CPU与SDRAM Controller以及Fast FLB连接方式\label{f_cpu_sdram_tcm}}
\end{figure}
\item 添加一个Interval Timer作为linux内核的系统时钟.周期设为\textbf{10 ms},计数器位宽\textbf{32 bit},Presets为\textbf{Full-featured}.
\underline{{\CJKfamily{ht}timer的中断优先级一定设置为0}}.
\item 添加一个JTAG-UART,默认设置.
\item 添加一个UART,默认设置.
\item 以上构成了linux运行所需的最小配置(严格来说,JTAG-UART和UART可以只选一个,但必须有).\textit{DE2-70}上晶振为50Mhz,
为提高系统运行速度,我们添加一个PLL,运行ALTPLL MegaWizard,启用两个输出c0和c1.将c0输出为输入的一倍(100Mhz),其余值默认.
将c1输出也设置为输入的一倍(100Mhz).唯一不同的是,c1的Clock phase shift设置为\textbf{-65 deg}.
\item 修改SOPC系统中每一个组件的时钟,除了PLL是默认的外部输入时钟外,其余均改为pll\_c0时钟.
\item 点击System菜单下的Auto-Assign Base Address自动分配各组件基址以消除地址冲突.注意Auto-Assign IRQs这个选项很可能会将timer的优先级
修改,如果使用,请一定小心.完成后SOPC Builder界面如图\ref{f_sopc}所示.保存当前设置.点击Generate生成SOPC系统.
\begin{figure}[!bthp]
\centering
\includegraphics[width=1\textwidth]{pic/f_sopc.eps}
\caption{完成设置的SOPC\label{f_sopc}}
\end{figure}
\item 在Quartus II下新建一个.v文件作为顶层文件\footnote{顶层模块名称,保存.v文件时文件名必须与该名称一致}.添加如下内容:
\begin{verbatim}
module NL(
  input         iCLK_50,        // 50 MHz
  //////////////////////////////// UART ////////////////////////////
  output        oUART_TXD,      // UART Transmitter
  input         iUART_RXD,      // UART Receiver
  //////////////////////////////// SDRAM Interface ////////////////////////
  inout  [31:0] DRAM_DQ,        // SDRAM Data bus 32 Bits
  output [12:0] oDRAM0_A,       // SDRAM0 Address bus 12 Bits
  output        oDRAM0_LDQM0,   // SDRAM0 Low-byte Data Mask 
  output        oDRAM0_UDQM1,   // SDRAM0 High-byte Data Mask
  output        oDRAM0_WE_N,    // SDRAM0 Write Enable
  output        oDRAM0_CAS_N,   // SDRAM0 Column Address Strobe
  output        oDRAM0_RAS_N,   // SDRAM0 Row Address Strobe
  output        oDRAM0_CS_N,    // SDRAM0 Chip Select
  output [1:0]  oDRAM0_BA,      // SDRAM0 Bank Address
  output        oDRAM0_CLK,     // SDRAM0 Clock
  output        oDRAM0_CKE      // SDRAM0 Clock Enable
);
wire CPU_CLK;
wire SYS_RESET_N;
assign SYS_RESET_N=1'b1;
Nios nios2 (
  .clk_in(iCLK_50),
  .pll_system(CPU_CLK),
  .pll_sdram(oDRAM0_CLK),
  .reset_n(SYS_RESET_N),
  .zs_addr_from_the_sdram_0(oDRAM0_A),
  .zs_ba_from_the_sdram_0(oDRAM0_BA),
  .zs_cas_n_from_the_sdram_0(oDRAM0_CAS_N),
  .zs_cke_from_the_sdram_0(oDRAM0_CKE),
  .zs_cs_n_from_the_sdram_0(oDRAM0_CS_N),
  .zs_dq_to_and_from_the_sdram_0(DRAM_DQ),
  .zs_dqm_from_the_sdram_0({oDRAM0_UDQM1,oDRAM0_LDQM0}),
  .zs_ras_n_from_the_sdram_0(oDRAM0_RAS_N),
  .zs_we_n_from_the_sdram_0(oDRAM0_WE_N),
  .rxd_to_the_uart_0(iUART_RXD),
  .txd_from_the_uart_0(oUART_TXD)
);
endmodule
\end{verbatim}
其中,Nios是构建的SOPC名称.将该文件设置为顶层文件.进行编译.编译结束后,查询\textit{DE2-70}数据手册,分配顶层各信号管脚.
再进行一次编译.整个硬件系统就搭建完毕.
\end{enumerate}
%%%4.2
\subsection{内核配置和编译}
现在我们来配置当前SOPC系统对应的linux内核.
\begin{enumerate}
\item 打开nios shell(如图\ref{ns}所示),进入到硬件工程所在目录下,运行:
\begin{verse}
sopc-create-header-files --single custom\_fpga.h\footnote{生成的头文件名字一定为\textbf{custom\_fpga.h}}
\end{verse}
这将会在该目录下生成名为\textbf{custom\_fpga.h}的C语言头文件.将这个文件拷贝到共享文件夹当中.
\item 启动虚拟机,输入如下命令:
\begin{verse}
cp -i /home/bearchen\footnote{这是我的Ubuntu虚拟机下用户名,请替换成你自己的用户名}/Desktop/VBS\footnote{这是我的共享文件夹名称,同样
请替换成你的}/custom\_fpga.h /opt/NiosIILinux/nios2-linux/linux-2.6/arch/nios2/include/asm/\\
确认替换当前已有文件
\end{verse}
\item 输入命令:
\begin{verse}
cd /opt/NiosIILinux/nios2-linux/uClinux-dist/\\
make clean\\
make menuconfig\\
\end{verse}
进入内核配置界面.由于本系统比较简单,除了JTAG-UART和UART外没有任何外设,因此内核中设备驱动部分只需设置两种串口驱动支持以及
哪一种设备作为终端输出.但是,有一些设置虽然只需配置一次,但影响全局,需要特别注意.为介绍整个过程,我们先将当前配置除去.
选择"Kernel/Library/Defaults Selection--->"进入.选中"Default all settings(lose changes)".退出保存.对遇到的所有提问选择'N'.将整个内核包
恢复到默认发布配置.
\item 再次运行\fbox{make menuconfig}.进入"Kernel/Library/Defaults Selection--->".选中"Customize Kernel Settings".退出保存.
\item 在新弹出的配置窗口,进入"NiosII Configuration--->",将"NiosII FPGA Configuration(MMU\_DEFAULT)"修改为"NiosII FPGA Configuration
(CUTOM\_FPGA)"
\item 在同一个窗口中将"Link address offset fot booting"的值改大,防止内核解压缩后的代码覆盖压缩内容,这里改为\textbf{0x00F00000}.
\item 退出到上一个界面,进入"Device driver--->Network device support--->Ethernet(10 or 100mbit)--->"将"Altera Triple Speed Ethernet 
MAC Support(SLS)"选项取消\footnote{开发包默认使用Stratix的开发板和这一款网络驱动,与本工程不符.若不取消,编译报错.}.退出保存.
\item 退回到"Device driver--->"下,进入"Character devices--->Serial drivers".选择JTAG-UART和UART驱动支持,并开启JTAG-UART终端(console)支持.
如图\ref{f_kcfg_ct}所示.设置完成,退出并保存.
\begin{figure}[!bhtp]
\centering
\includegraphics[width=0.6\textwidth]{pic/f_kcfg_char_terminal.eps}
\caption{内核配置:终端配置\label{f_kcfg_ct}}
\end{figure}
\item 运行\fbox{make}.内核编译完成.将images/zImage.initramfs.gz拷贝到共享文件夹\footnote{{\CJKfamily{ht}共享文件夹是联系宿主机和
虚拟机的通道,在宿主机和虚拟机中都有一个相应的文件夹进行关联}}中.
\end{enumerate}
%%%4.3
\subsection{下载运行}
此时在宿主机的共享文件夹中就存在有从虚拟机拷贝出来的内核镜像文件,为了让linux在开发板上跑起来,需要按顺序下载{\CJKfamily{ht}硬件sof文件,
内核镜像文件}.

下载sof文件有两种方法,一种是在Quartus II中直接调用Programmer下载,另一种通过nios shell下调用命令来进行.这里采用第二种.将硬件sof文件和
内核文件拷贝到同一个文件夹下.连接好\textit{DE2-70}开发板的下载线和电源,上电,在nios shell下进入该文件夹,运行如下命令:
\begin{verse}
nios2-config-sof <sof文件> \&\& nios2-download -g <内核镜像文件> \&\& nios2-terminal
\end{verse}
下载完成后,将会看到大量的打印信息,最终在shell上会出现类似Ubuntu下终端提示符的界面,如图\ref{f_kb}所示.你可以输入ls命令查看当前开发板上的
文件系统,进入/bin目录运行可执行文件等.当你执行这些操作时,恭喜你,linux已经在开发板上跑起来了.
\begin{figure}[!bhtp]
\centering
\includegraphics[width=0.8\textwidth]{pic/f_kernel_bootingmsg.eps}
\caption{内核启动完成\label{f_kb}}
\end{figure}

提醒:对于入门的同学,掌握整个开发流程是必要的;而对于进行大规模系统开发的同学,建议使用模板进行修改,效率会得到很大的提高.
%%%%%%%%%%%%%%%%%%%%开发前需要了解的知识%%%%%%%%%%%%%%%
\newpage{}
\section{开发前需要了解的知识}
\setcounter{footnote}{0}
本节将介绍一些开发所需要的背景知识,但不会进行深入的讨论.一来笔者本身也只留于表面;二来有违本文宗旨,且篇幅不允许.

通过上一节的例子,读者应该对NIOS II Linux系统开发的基本步骤有了大概的认识.至于每一步的目的是什么恐怕会有许多迷惑.本节将对内核开发中的若干
问题进行解释.纯属个人理解,水平有限,如有不对的地方,欢迎同学与我\href{mailto:cfistalent@gmail.com}{联系}.
%%%5.1
\subsection{内核开发包目录结构}
解压完内核开发包,生成名为"nios-linux"的文件夹,进入该文件夹,可以看到有如下内容:
\begin{quote}
3c120\_default binutils checkout elf2flt gcc3 glibc insight\\
linux-2.6 README sshkey toolchain-build toolchain-mmu\\
u-boot uClibc uClinux-dist update use\_git\_for\_update\\
use\_http\_for\_update use\_ssh443\_for\_update
\end{quote}
其中有几个比较重要:
\begin{description}
\item[\textit{linux-2.6}] 保存了linux内核的所有相关代码,其中大部分是各种驱动程序.驱动程序移植和开发工作都将在这个目录下
的driver目录中进行.同时arch/nios目录下保存有nios处理器相关的底层代码,包括各种片上系统对应的头文件,内核启动代码,各种片上外设的配置等.
\item[toolchain-mmu] 存有nios linux开发工具集,包括gcc,gdb等.
\item[u-boot] 存有引导linux操作系统的著名的bootloader.
\item[glibc] nios linux下开发应用程序所采用的标准C语言库函数.
\item[\textit{uClinux-dist}] 这是开发时大部分时间都将要驻留的文件夹,在这个文件夹中,有nios linux下应用程序开发时使用的各种库函数
,也有已经移植到nios linux下的各种应用程序,二者都以源码的形式存放在这个文件夹的lib和user文件夹中.
同时,这里也是运行内核配置,编译内核等命令的目录.随后我会作进一步介绍.
\item[uClibc] 内核开发包中其实包含了两个操作系统源码,带MMU的nios处理器支持的linux和不带MMU的nios处理器支持的uClinux.而uClibc就是
uClinux系统下C语言的标准函数库.两个操作系统源码存在于git(见\pageref{git}页)\footnote{Linus开发的一个分布式版本管理系统}的两个不同分支中,
通过\fbox{git checkout}命令切换.
\item[checkout] 这是一个shell脚本,通过该脚本可利用git更新本地各个文件夹源码的版本.
\end{description}

nios linux内核开发包中,除了移植到nios处理器上的linux内核代码,还包含有大量应用程序库函数和各种应用程序的源代码,通过配置菜单决定
每个函数库和应用程序是否被编译,生成的应用程序是否会放入RAM文件系统中.这些库和程序都在uClinux-dist文件夹中.

进入uClinux-dist,有如下内容:
\begin{quote}
auto.conf  config         images       Makefile     release\_notes  tools
autoconf.h  config.arch    Kconfig      Makefile.am  romfs          user
bfin\_patch  COPYING        lib          Makefile.in  SOURCE         vendors
bin         Documentation  linux-2.6.x  openswan     staging
ccache      freeswan       MAKEALL      README       testsuites
\end{quote}
其中有几个比较重要:
\begin{description}
\item[images] 编译内核生成的可执行文件会被放到这个文件夹中.
\item[romfs] 用来生成RAM文件系统的暂存文件夹,nios linux运行时文件系统中的所有文件都来自这里.因此,如果有自定义的文件
需要放置到文件系统中,可将其放入本文件夹,运行\fbox{make romfs}即可.
\item[user] 这里有各种应用程序,如web服务器,网络工具,磁盘工具等linux应用程序.我们自行编写的应用程序也将放在这里.
\item[lib] 这里有各种函数库,如jpeg编解码库,触摸屏设备坐标提取库等等.
\item[vendors] 里面是以公司或产品为名称的文件夹,包含有针对各款产品移植的linux对应的配置文件,如设备文件,shell初始化完毕后执行的脚本文件
等等.nios linux只与"Altera"和"Generic"两个文件夹相关.
\item[staging] user中的应用程序大部分都依赖lib里的函数库,编译过程也是先lib再user,为了编译user中的应用程序时编译器能找到对应的依赖库函数
和头文件,编译完lib后会将其中的.a,.so以及.h文件拷贝到staging中,方便user的编译过程.
\end{description}

这里解释一下什么是RAM文件系统.在以nios为中心的嵌入式系统中,硬盘和大容量flash不是必须组件,因此,linux运行所需的文件系统需要放在一个必须存在
的组件当中.而内存无论以onchip ram,sdram还是sram的形式存在,都是nios嵌入式系统必须的,故内核开发包中构建了ram filesystem.生成的内核可执行
文件中,名为"zImage.initramfs.gz"的镜像包含了linux内核以及RAM文件系统.上电运行时,解压缩代码将会把内核和文件系统解压缩到指定的内存地址当中.

内核以Kconfig文件管理所有组件是否被编译,以makefile文件管理编译过程."config/.config"文件包含当前应用层配置情况(包括函数库和应用程序),
"linux-2.6.x/.config"包含当前linux内核配置情况.可通过备份这两个文件保存当前配置.
%%%5.2
\subsection{三个重要的文件}
构建SOPC系统的时候,可以添加各种外设,如uart,spi,gpio等.这些外设的名称又因人而异,而内核中,典型外设的驱动是支持的,比如串口.如何让驱动程序
支持不同设计者构建的SOPC系统?碰到内核不支持的驱动如何处理?这是本小节需要解释的内容.

内核开发包的linux源码中已支持多种设备驱动,绝大多数SOPC外设对应的驱动程序都属于"platform driver".每一个"platform driver"都有一个
"platform device"相对应\footnote{linux内核初始化过程中,会先注册若干"platform device",之后编译进内核的"platform driver"将会匹配已注册
的平台设备,若匹配成功,则利用平台驱动初始化该设备.}.在"<内核开发包路径>/nios2-linux/linux-2.6/arch/nios2/kernel"中,有一个名为
\textbf{config.c}的文件,这个文件部分内容如下所示:
\begin{verbatim}
/*Altera JTAG UART*/
#if defined(CONFIG_SERIAL_ALTERA_JTAGUART)
static struct altera_jtaguart_platform_uart nios2_jtaguart_platform[] = {
#ifdef JTAG_UART_BASE
	{
	 .mapbase = JTAG_UART_BASE,
	 .irq = JTAG_UART_IRQ,
	 },
#endif
	{},
};

static struct platform_device nios2_jtaguart = {
	.name = "altera_jtaguart",
	.id = 0,
	.dev.platform_data = nios2_jtaguart_platform,
};
#endif
/*Altera UART*/
#if defined(CONFIG_SERIAL_ALTERA_UART)
static struct altera_uart_platform_uart nios2_uart_platform[] = {
#ifdef UART_0_BASE
	{
	 .mapbase = UART_0_BASE,
	 .irq = UART_0_IRQ,
	 .uartclk = UART_0_FREQ,
	 },
#endif
	.......
	.......
	{},
};
static struct platform_device nios2_uart = {
	.name = "altera_uart",
	.id = 0,
	.dev.platform_data = nios2_uart_platform,
};
#endif
\end{verbatim}
可以看到,其中使用了很多宏定义,形如CONFIG\_XXXX的宏来自Kconfig配置生成的头文件.而其他宏则来自custom\_fpga.h文件
(在"<内核开发包路径>/nios2-linux/linux-2.6/arch/nios2/include/asm"中,后面要介绍的\textbf{nios.h}也来自该路径).

config.c中定义了很多平台设备,如uart,jtag-uart,mmc spi,dm9000等等.他们都通过一个条件编译宏指令控制是否参与最终的编译.以UART为例,
当定义了\textbf{UART\_0\_BASE}时,对应平台设备的参数如.mapbase等就会得到配置.linux支持四个串口设备,因此如果分别定义了
\textbf{UART\_1\_BASE,UART\_2\_BASE,UART\_3\_BASE},则将会有四个串口平台设备得到注册.

从另一个角度说,若config.c中没有开启某个宏进行平台设备注册,则该设备的平台驱动编译进内核后初始化时将找不到匹配设备\footnote{仅适用于
平台设备和平台驱动}.

nios.h定义了一个系统的基础组件如内存基址和大小,定时器设置以及作为系统终端的UART和JTAG-UART的设备基址等.同时还定义了nios中断号等
系统关键内容.该文件部分内容如下所示:
\begin{verbatim}
#if defined(CONFIG_NIOS2_DEFAULT_MMU)
#include <asm/default_mmu.h>
#elif defined(CONFIG_NIOS2_MAXIMUM_MMU)
#include <asm/maximum_mmu.h>
#elif defined(CONFIG_NIOS2_CUSTOM_FPGA)
#include <asm/custom_fpga.h>
#else
#error "No FPGA configuration selected
#endif

/* 2C35 dev board */
#ifdef TIMER_0_FREQ

#define CONFIG_ALTERA_CYCLONE_II
#define DDR2_TOP_BASE SDRAM_0_BASE
#define DDR2_TOP_SPAN (SDRAM_0_SPAN)

#define TIMER_1MS_FREQ TIMER_0_FREQ
#define TIMER_1MS_BASE TIMER_0_BASE
#define TIMER_1MS_SPAN TIMER_0_SPAN
#define TIMER_1MS_IRQ TIMER_0_IRQ

#define UART_BASE UART_0_BASE
#define UART_SPAN UART_0_SPAN
#define UART_IRQ UART_0_IRQ
#define UART_FREQ UART_0_FREQ

#define JTAG_UART_BASE JTAG_UART_0_BASE
#define JTAG_UART_SPAN JTAG_UART_0_SPAN
#define JTAG_UART_IRQ JTAG_UART_0_IRQ

#endif
\end{verbatim}
可以看到,针对不同的系统配置,该文件将会包含不同的头文件.这就解释了之前在进行第一个工程内核配置操作中为何要选择"CONFIG\_NIOS2\_CUSTOM\_FPGA"
.由该文件内容可以看到,这些系统基本组件的名称是固定的,如串口基址为UART\_0\_BASE.这些被替代的宏都来自于用户设计SOPC所生成的.C头文件
\textbf{custom\_fpga.h}.

现在,我们再看看上一节中生成的custom\_fpga.h的部分内容:
\begin{verbatim}
#define CPU_IMPLEMENTATION "fast"
#define CPU_FREQ 100000000u
#define ICACHE_LINE_SIZE 32
#define ICACHE_LINE_SIZE_LOG2 5
#define ICACHE_SIZE 4096
#define DCACHE_LINE_SIZE 32
#define DCACHE_LINE_SIZE_LOG2 5
#define DCACHE_SIZE 2048
......
#define MMU_PRESENT 
#define KERNEL_REGION_BASE 0xc0000000
#define IO_REGION_BASE 0xe0000000
#define KERNEL_MMU_REGION_BASE 0x80000000
#define USER_REGION_BASE 0x0
......
#define EXCEPTION_ADDR 0xc2000020
#define RESET_ADDR 0xc2000000
#define BREAK_ADDR 0xc4000820
......
#define SDRAM_0_COMPONENT_TYPE altera_avalon_new_sdram_controller
#define SDRAM_0_COMPONENT_NAME sdram_0
#define SDRAM_0_BASE 0x2000000
#define SDRAM_0_SPAN 33554432u
......
#define TIMER_0_COMPONENT_TYPE altera_avalon_timer
#define TIMER_0_COMPONENT_NAME timer_0
#define TIMER_0_BASE 0x4001400
#define TIMER_0_SPAN 32u
#define TIMER_0_IRQ 0
......
#define TIMER_0_FREQ 100000000u
#define TIMER_0_LOAD_VALUE 999999ULL
#define TIMER_0_COUNTER_SIZE 32
#define TIMER_0_MULT 0.0010
#define TIMER_0_TICKS_PER_SEC 100u
......
#define UART_0_COMPONENT_TYPE altera_avalon_uart
#define UART_0_COMPONENT_NAME uart_0
#define UART_0_BASE 0x4001440
#define UART_0_SPAN 32u
#define UART_0_IRQ 2
#define UART_0_BAUD 115200
......
#define JTAG_UART_0_COMPONENT_TYPE altera_avalon_jtag_uart
#define JTAG_UART_0_COMPONENT_NAME jtag_uart_0
#define JTAG_UART_0_BASE 0x4001460
#define JTAG_UART_0_SPAN 8u
#define JTAG_UART_0_IRQ 1
......
\end{verbatim}
这里面定义了SOPC系统的所有基本信息,各种外设的基址及中断等相关信息.是内核其他文件中硬件相关宏定义的主要来源
\footnote{Tips:当内核编译时报错"macro xxx not defined",请检查custom\_fpga.h和config.c中对应设备宏定义是否相同.}.

custom\_fpga.h中各设备宏名称来自构建的SOPC系统组件名称.因此,有两种方法让添加的设备正常运行:
\begin{itemize}
\item 自定义SOPC组件名称,之后修改nios.h和config.c文件中相关宏与custom\_fpga.h一致.
\item 采用nios.h和config.c中指定的设备名称.
\end{itemize}
显然,第二种方法相对而言要容易的多.这就是在uClinuxWiKi上经常可以看到使用某设备时需将该设备命名为指定名称的原因.
%%%5.3
\subsection{内核开发中使用的部分工具简介}
在开发过程中,会有一半以上的时间使用命令行工具而不是GUI界面.尤其是在硬件系统搭建完毕后,软件部分的开发都将处于command line界面.
本小节对一些必须或很可能使用的CLTs(Command Line Tools)作简要介绍.
%%%5.3.1
\subsubsection{NiosII相关工具}
Altera公司针对NiosII处理器提供了一套build tools.方便那些习惯了命令行的开发者,在\textbf{Nios II Software Developer's Handbook}9.0版本
的三,四章有较详细的介绍.这里只针对nios linux开发作相关的介绍.如表\ref{nios_clts}所示.
\begin{table}[!bthp]
%\setlength{\belowcaptionskip}{-15pt}
\begin{threeparttable}
\centering
\begin{tabular}{|p{0.3\textwidth}|p{0.65\textwidth}|}
\hline
sopc-create-header-file\tnote{1} & 从构建的SOPC系统生成对应的.C头文件.用法如sopc-create-header-file --single custom\_fpga.h
\tnote{2}\\\hline
nios2-config-sof & 将硬件系统编译生成的sof文件通过usb-blaster下载到FPGA中.使用方法是该命令+sof文件名\\\hline
nios2-download & 将软件代码下载到内存中,用法nios2-download -g <文件名>\\\hline
nios2-terminal & 当软件选择JTAG-UART作为终端时,通过本命令可看到打印的信息.\\\hline
elf2flash & 将可执行文件转为flash烧写文件\\\hline
sof2flash & 将sof文件转为flash烧写文件\\\hline
nios2-flash-programmer & 将文件烧进flash的命令\\\hline
\end{tabular}
\caption{NiosII相关CLTs\label{nios_clts}}
\begin{tablenotes}
\footnotesize
\item[1] 这些命令在Windows和Linux中都存在,取决于NiosII IDE安装在哪一种环境中.在本文推荐的环境中,这些命令都在nios shell中运行.
\item[2] 注意,该命令需要当前文件夹有\textbf{.sopcinfo}文件,该文件一般在硬件工程根目录中.
\end{tablenotes}
\end{threeparttable}
\end{table}
%%%5.3.2
\subsubsection{make}
通过之前内容的阅读可知道,在uClinux-dist目录中运行\fbox{make menuconfig}可以打开内核配置菜单,运行\fbox{make image}可以生成内核镜像.

严格的说,这些命令并不是独立的可执行程序,他们只是Makefile文件中的标号,表明一段脚本.好奇的同学可以打开uClinux-dist下的Makefile文件,
这里有详细的代码.这里仅列出常用的命令.
\begin{description}
\item[make] 运行Makefile中默认的脚本,在这里意味着将会完成编译内核,函数库,应用程序,准备文件系统,生成镜像文件等等.
\item[make menuconfig] 打开图形化配置界面.
\item[make clean] 清除所有编译生成的文件.但会保留当前的配置.
\item[make mrproper] 清除所有编译生成的文件,包括当前配置.以及各种备份文件.
\item[make modules] 只编译生成内核模块.
\item[make image] 跳过编译和文件系统环节,根据当前配置直接生成镜像文件.用于只是向romfs中增删文件后重新生成镜像文件.
\end{description}
%%%5.3.3
\subsubsection{Git}\label{git}
在没有版本管理工具之前,我们是如何管理自己编写的软件的呢?常见的方法是将当前已达到某种阶段的代码所在文件夹打包,编写一个ReadMe文档,说明
当前已实现功能以及日期等.下一个版本就在当前文件夹继续进行,直到下一次打包.如果某一次打包后编写的代码出现不可调和的故障,且代码无法还原.
只好解压之前的打包文件,替代当前文件夹.时间一长,就不容易区分各个版本之间具体区别,造成文件多且难以管理的情况.

Git是一个分布式版本管理系统.所谓分布式,指的是项目的所有版本源码都存在本地,在本地就可进行各种版本源码间的比较,切换工作.不像SVN和CVS这些
基于服务器的版本管理系统,获取到本地的项目永远是当前最新的版本,历史源码都存在服务器端.有关Git的详细使用说明请参看
\href{http://progit.org/book/}{这里}.

内核开发包根目录下的很多文件夹都采用Git作为版本管理工具,这些文件夹都是一个Git工作目录,在其中都有一个.git文件夹,这是Git仓库.开发者在工作
目录中修改,编写代码,确认达到要求后,将当前改动提交进入仓库.需要还原时,从仓库中取出.在Ubuntu下通过\fbox{sudo apt-get install git-core}安装
git工具.接下来对Git的常用命令做一个简要介绍.
\begin{description}
\item[git init] 初始化一个Git仓库.
\item[git config --global xxx] Git全局配置.如\fbox{git config --global user.name xxx}配置版本管理者名称,
\fbox{git config --global user.email xxx@xxx.xxx}配置管理者邮箱.
\item[git add ] 添加改动到缓冲区.
\item[git commit] 提交改动到仓库\footnote{Tips:通常有两种方法提交改动,一种是先后运行"git add ."和"git commit"命令,
一种是运行"git commit -a"命令.}.
\item[git diff] 查看不同版本的区别.
\item[git log] 查看日志.
\item[git reset --hard xxx] 退回到某个版本.
\end{description}
内核开发包本身已经是一个由Git进行管理的工作目录.不需要创建和初始化工作.平时需要作的事情主要有:
\begin{itemize}
\item 编写代码,测试完成后,提交版本;
\item 比较两个版本之间的差别;
\item 恢复到某一个版本;
\end{itemize}
如果有必要,还可以通过\fbox{git pull}命令从远方的服务器抓取内核和其他开发包的官方更新.不过由于网络等原因,不推荐这么做.
%%%5.3.4
\subsubsection{GNU Autotools}
如果你在某一个应用程序源代码的目录下看到如"Makefile.am","configure.ac"等文件,该应用程序使用GNU Autotools进行工程管理而不是通常意义上
的makefile文件,虽然本质上该应用程序最终还是通过makefile文件进行编译,安装等工作.\textbf{请注意这里说的是工程管理工具,而不是版本管理工具}.
关于Autotools的详细内容可以参看\href{http://www.lrde.epita.fr/~adl/autotools.html}{这个教程}.

以下内容是笔者总结的使用Autotools进行工程管理的一种方式,有兴趣的同学可以看一下:
\begin{enumerate}
\item 确保autoconf,automake,aclocal等工具已经安装,若没安装,通过以下命令安装:\fbox{sudo apt-get install automake libtool}.
\item 创建工程目录,目录结构为:
\begin{quote}
project root\\
\indent{}|\\
\indent{}--->src/\\
\indent{}|\\
\indent{}--->include/
\end{quote}
\item 分别在src目录和include目录创建源码文件和头文件.
\item 在根目录创建Makefile.am文件.内容模板如下:
\begin{quote}
SUBDIRS = src include\\
\end{quote}
\item src/和include/目录Makefile.am文件模板如下:
\begin{quote}
\#\#\#\#src/Makefile.am
bin\_PROGRAMS = ftk\_file\\
ftk\_file\_SOURCES = main.c ftk\_file.c\\
AM\_CFLAGS = -I\${top\_srcdir}/include \\
AM\_CFLAGS += -I/opt/Ftk-pc/ftk-0.4/src/\\
LDFLAGS = -lftk -lpng -ljpeg\\
LDFLAGS += -L/opt/Ftk-pc/ftk-0.4/src/.libs/\\
\#\#\#\#include/Makefile.am\\
include\_HEADERS = debug.h ftk\_file.h all.h
\end{quote}
\item 在工程根目录使用autoscan自动扫描工程生成configure.scan,将其改为configure.ac并修改其内容.模板如下:
\begin{quote}
\#            -*- Autoconf -*-\\
\# Process this file with autoconf to produce a configure script.\\
AC\_PREREQ([2.63])\\
AC\_INIT(ftk\_file, 0.1, cfistalent@gmail.com)\\
AM\_INIT\_AUTOMAKE([-Wall -Werror foreign])\\
AC\_CONFIG\_SRCDIR([src/main.c])\\
AC\_CONFIG\_HEADERS([config.h])\\
\# Checks for programs.\\
AC\_PROG\_CC\\
\# Checks for libraries.\\
\# Checks for header files.\\
AC\_CHECK\_HEADERS([stdlib.h string.h])\\
\# Checks for typedefs, structures, and compiler characteristics.\\
\# Checks for library functions.\\
AC\_CONFIG\_FILES([Makefile\\
include/Makefile\\
src/Makefile])\\
AC\_OUTPUT
\end{quote}
\item 使用aclocal-->autoheader-->autoconf-->automake生成configure脚本,为简化操作可以编写脚本自动实现以上几个命令:
\begin{quote}
\#!/bin/bash\\
echo "aclocal"\\
aclocal || exit 1\\
echo "autoheader"\\
autoheader || exit 1\\
echo "autoconf"\\
autoconf --force || exit 1\\
echo "automake"\\
automake --force --add-missing || exit 1
\end{quote}
将该文件保存为autogen.sh,赋予它可执行权限.
\item 编写Makefile使工程在一个独立的文件夹build中运行configure:
\begin{verbatim}
    all:build/Makefile
        make -C build
    build/Makefile:
        rm -rf build; \
        mkdir build; \
        cd build; \
        ../configure
    clean:
        rm -rf build*
    dist:
        cd build; \
        make dist
    .PHONY:clean dist
\end{verbatim}
\item 注意事项:
\begin{itemize}
\item 如果修改了Makefile.am文件,需要重新运行aclocal等命令生成configure文件;
\item 需要的头文件和库函数可以在src下的Makefile.am中通过AM\_CFLAGS和LDFLAGS添加.在嵌入式平台上移植时需要在Makefile的
configure命令后添加配置参数,同时之前所提到参数也可以修改;
\end{itemize}
\end{enumerate}
%%%5.4
\subsection{第三方IP和AUP的使用}
很多公司如友晶都会针对nios提供自定义外设IP,一些IP还会得到内核开发包驱动支持.而Altera官方支持的大学计划IP
(Altera University IP Programme,AUP)更是在开发包中有广泛的支持.本小节介绍这两种IP的使用方法.

从本文的附加材料中可以找到名为"TERASIC\_DM9000A.rar"\footnote{本小节提到的这些IP包都可以在网络上搜的到.
包括Altera官方的FTP,友晶公司的FTP等}的压缩包.将其解压缩后拷贝到第四节我们制作的第一个工程\textbf{Nios2\_Linux\_C4}的根目录中.
该文件夹包含了友晶公司提供的DE2及DE2-70开发板上带有的网络芯片DM9000的自定义IP.同时该IP也被内核开发包驱动所支持.

打开SOPC Builder,打开菜单栏上的\fbox{Tools-->options}对话框,选择"IP Search Path"一栏,点击Add按钮,将"TERASIC\_DM9000A"文件夹加入搜索路径.
确定后SOPC Builder会在指定地址重新搜索可用IP.完成后,在左侧的"System Contents"标签下会出现"Terasic Technologies Inc."一栏,点击打开发现
其中存在一个名为"DM9000A\_IF"的IP.之后双击该IP就可将其添加到自己的SOPC系统中.

如果此时还没有出现该IP,则可通过手动方式添加.方法如下:
\begin{enumerate}
\item 打开SOPC Builder主菜单上\fbox{File-->New Component...}进入\textbf{Component Editor};
\item 在\textbf{Component Editor}中,点击菜单上的\fbox{File-->Open}打开文件浏览对话框,选择\textbf{TERASIC\_DM9000A}文件夹下名为
"DM9000A\_IF\_hw.tcl"的文件打开.检查各个标签页是否有红色警告,若无,则确定退出即可.
\end{enumerate}

AUP的使用更为简单,在附加材料中,将"altera\_up\_avalon\_pixel\_buffer.rar"和"altera\_up\_avalon\_vga.rar"解压到\textbf{当前文件夹}
会得到两个同名文件夹,将这两个文件夹拷贝到工程的\underline{\textbf{根目录}}.注意笔者强调的重点,这两个文件夹只有放置在工程根目录上,
才会被SOPC Builder搜索到.

打开SOPC Builder,左侧"System Contents"中出现"University Program"一栏,一路展开,发现出现两个IP"Pixel Buffer for VGA Display"和"VGA".
%%%5.5
\subsection{Avalon Memory-Mapped Bridges}
在较为复杂的系统中,经常会碰到以下两种情况的设计:
\begin{itemize}
\item 有多个主设备挂载在Avalon总线上,通过总线尽量并行地访问设备.碰到同一个从设备同时被多个主设备访问,总线进行仲裁活动.典型例子如
一个CPU加上一个DMA.
\item 主设备和存储设备在不同的时钟频率下运行.比如CPU跑在100Mhz,而SDRAM控制器和SDRAM跑在166Mhz.再比如,带有显示设备缓存的系统中,
显存使用SRAM,跑在80Mhz,而CPU跑在100Mhz.
\end{itemize}
从8.0版本开始,Altera提供Avalon Memory-Mapped Bridges针对以上两种情况优化系统性能.包括\textbf{Avalon-MM Pipeline Bridge}和
\textbf{Clock Crossing Bridge}\footnote{还有一个\textbf{Avalon-MM DDR Memory Half-Rate Bridge}笔者没有用过,不作介绍.有兴趣的同学可以
在QuartusII HandBook Volumn4:SOPC Builder的Charpter11找到详细描述}.

这些基于内存映射模型的桥都具有一个从端口和一个主端口,从端口与各种主设备相接,主端口则接入各种从设备.假设当前有两个CPU,需要访问一片共同的
存储区域,在这种情况下通常还需要一个MUTEX硬核来保证该区域访问的唯一性.将CPUs和ram以及mutex之间加入\textbf{Avalon-MM Pipeline Bridge}
的好处有两点:
\begin{enumerate}
\item 消除了ram和mutex各自的仲裁逻辑,共享一个仲裁逻辑.这降低逻辑单元使用率,减少信号传播延时.最终,起到的效果就是提高系统时钟频率Fmax.
\item 大大降低了系统内部网络结构的复杂度.
\end{enumerate}

同样的,假设系统中有一个跑在166Mhz的SDRAM控制器,访问它的CPU则跑在120Mhz.在二者之间插入一个\textbf{Avalon-MM Clock Crossing Bridge}的
作用是:
\begin{enumerate}
\item 允许CPU和SDRAM控制器在不同的时钟频率上运行.
\item 将仲裁逻辑的系统互联结构和SDRAM控制器的复用器放在慢的时钟域里.
\item 提高系统时钟频率Fmax.
\end{enumerate}

图\ref{f_ppl}展示了\textbf{Avalon-MM Pipeline Bridge}在系统中的连接方式.
\begin{figure}[!bhtp]
\centering
\includegraphics[width=0.7\textwidth]{pic/f_sopc_pipeline_bridge.eps}
\caption{pipeline bridge在sopc系统中的连接方式\label{f_ppl}}
\end{figure}
%%%5.6
\subsection{如何使用内核自带的设备驱动}
内核开发包中带有很多现成的驱动程序,这些驱动程序对应特定的外设.下面笔者以MMC/SD卡为例说明如何开启SD卡支持\footnote{没有特殊说明,硬件
开发环境始终是\textit{DE2-70}}.

\begin{enumerate}
\item 由于\textit{DE2-70}上SD卡槽只支持SPI模式\footnote{dat,cmd,clk,ss四根信号线},因此在SOPC系统中只需添加一个SPI模块,将其命名为
\underline{\textbf{mmc\_spi}}\footnote{前面的内容强调过,命名与config.c文件宏对应一致}.重新生成SOPC,并在顶层连接好信号线,分配管脚,重新编译.
\item 重新生成custom\_fpga.h,覆盖内核开发包同名文件.
\item 进入内核配置界面\footnote{这里的内核界面指的是运行\fbox{make menuconfig}后选择"Kernel/Library/Defaults selection--->
Customizes Kernel Settings"保存退出后出现的界面.},配置以下几个内容:
\begin{itemize}
\item "Device Drivers--->SPI Support--->Altera SPI Controller"选中,开启SPI协议设备驱动支持;
\item "Device Drivers--->MMC/SD Card support--->"下选中"MMC block device driver","Use bounce buffer for simple hosts"以及"MMC/SD over SPI"
开启MMC/SD卡驱动支持;
\item  "File systems--->"中,"DOS/FAT/NT Filesystems--->"下开启"VFAT (Windows-95) fs support","-*- Native language support--->"下开启
"Codepage 437 (United States, Canada)","Simplified Chinese charset (CP936, GB2312)"和
"NLS ISO 8859-1  (Latin 1; Western European Languages)"中英文编码支持.完成后保存退出;
\item 内核编译下载后,与开发板相连的终端(JTAG-UART或UART)上看到类似如下打印消息表示SD卡已被支持:
\begin{quote}
mmc\_spi spi2.0: ASSUMING SPI bus stays unshared!\\
mmc\_spi spi2.0: ASSUMING 3.2-3.4 V slot power\\
mmc\_spi spi2.0: SD/MMC host mmc0, no DMA, no WP, no poweroff\\
mmc0: host does not support reading read-only switch. assuming write-enable.\\
mmc0: new SDHC card on SPI\\
mmcblk0: mmc0:0000 SA04G 3.68 GiB\\
 mmcblk0: p1\\
\end{quote}
\item 在开发板终端运行如下命令:
\begin{verse}
mount /dev/mmcblk0p1 /mnt
\end{verse}
将SD卡挂载到/mnt目录下,此时,进入/mnt目录将看到SD卡的内容.
\end{itemize}
\end{enumerate}

大部分的支持设备如何在内核进行配置操作在NiosWiki的uClinux主页上有详尽介绍,需要用某种设备时可参考
\href{http://www.nioswiki.com/OperatingSystems/UClinux}{该网页}.
%%%%%%%%%%%%%%%%%%%%无界面应用程序编写%%%%%%%%%%%%%%%
\setcounter{footnote}{0}
\newpage{}
\section{无界面应用程序编写}
本节介绍linux下普通应用程序构建以及如何加入内核开发包中.\textbf{注意,本节之后的内容均可以本文附带材料
Nios2\_linux\_Total工程为硬件进行操作.}

由于linux操作系统之间普遍的可移植性,PC机上编写的代码用nios linux对应的编译器\footnote{nios2-linux-gnu-gcc}进行编译后就能在开发板上运行.
这为开发者提供了一个很好的开发思路:先在Ubuntu等linux平台的主机上编写应用程序,待验证无误后,再放置到nios linux中编译,最后进行开发板上的
测试工作.这是一个很好的思路,实现这种思路的前半部分没有区别(在PC机上编写,调试代码),后半部分却有很多种实现方案:
\begin{itemize}
\item 最便捷,也是嵌入式linux开发中用的最多的一种方案.在PC机上使用交叉编译工具(如nios2-linux-gnu-gcc)进行编译,通过开发板上提供的网口和
linux提供的网络功能利用NFS\footnote{网络文件系统,将开发板上的文件系统通过网络关联到PC机上的某一个文件夹,使得PC机上能对开发板的文件系统
进行访问,反之亦然.}挂载到PC机的某一个目录,将编译好的可执行文件拷贝到该目录,通过开发板访问并执行.可惜,目前这个方案在nios linux中
\textbf{暂时无法实现}.
\item 将应用程序源码工程加入内核开发包中,使最终生成的可执行文件出现在RAM文件系统中.内核下载完毕后,在RAM文件系统中就存在该应用程序的可执行
文件.
\item 在PC机上交叉编译,生成的可执行文件拷贝到U盘或SD卡当中,下载内核后,通过访问U盘或SD卡实现应用程序调试运行.这中方案要求支持相应的
存储设备.
\end{itemize}
撇开第一种方案不谈,2,3两种方案各有优缺点.方案2的缺点是修改代码后重新编译一次的时间较长,适合已经测试完毕准备发布的应用程序.方案3附加条件
较多,需要外扩存储设备支持.读者可以根据自身需求选择这两种开发方式.接下来通过一个简单的"hello world"应用程序介绍一下3,2这两套方案.
\begin{enumerate}
\item 在Ubuntu上创建一个文件夹,这里命名为hello.在其中新建两个文件main.c和Makefile,在main.c中输入如下代码:
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char* argv[])
{
    printf("hello nios linux!\n");

    return 0;
}
\end{verbatim}
可以看到,该程序做的事情就是向标准输出设备打印一条语句,然后退出.
\item 在Makefile中编写如下代码:
\begin{verbatim}
OBJ=$(patsubst %.c,%.o,$(wildcard *.c))
BIN=hello

$(BIN):$(OBJ)
    $(CC) -o $@ $^ $(LDFLAGS)

%.o:%.c
    $(CC) -c -o $@ $< $(CFLAGS)

clean:
    rm *.o $(BIN)

.PHONY:clean
\end{verbatim}
也许会有同学感到奇怪,OBJ和BIN是在文件头定义的变量,那CC为何不需要定义呢?因为CC默认值为gcc.这也为之后的移植提供了便利,只需要重新定义CC
的值为nios平台的编译器.
\item 在该目录下运行\fbox{make}即可生成可执行文件hello.之后运行\fbox{./hello}将看到类似下面的输出:
\begin{verbatim}
$ make
cc -c -o main.o main.c 
cc -o hello main.o 
$ ./hello 
hello nios linux!
\end{verbatim}
证明程序已经在PC机上运行正确.
\item 运行\fbox{make clean},再运行\fbox{make CC=nios2-linux-gnu-gcc},重新生成可执行文件,然后再一次执行\fbox{./hello}会有如下内容:
\begin{verbatim}
$ make clean
rm *.o hello
$ make CC=nios2-linux-gnu-gcc
nios2-linux-gnu-gcc -c -o main.o main.c 
nios2-linux-gnu-gcc -o hello main.o 
$ ./hello 
bash: ./hello：无法执行二进制文件
\end{verbatim}
可见修改CC后使用的编译器已经变为nios平台的nios2-linux-gnc-gcc.而最后一行说明该可执行程序不是基于x86结构的linux下的文件.
将其拷贝到SD卡中,插入\textit{DE2-70},下载内核,挂载SD卡后进入,运行hello,可得到相应输出.
\item 接下来的步骤用来说明方案2如何实现.将文件夹连同两个文件拷贝到"<内核开发包安装目录>/nios2-linux/uClinux-dist/user/".同时修改
Makefile文件如下:
\begin{verbatim}
OBJ=$(patsubst %.c,%.o,$(wildcard *.c))
BIN=hello

$(BIN):$(OBJ)
    $(CC) -o $@ $^ $(LDFLAGS)

%.o:%.c
    $(CC) -c -o $@ $< $(CFLAGS)

clean:
    rm *.o $(BIN)

romfs:                                 *
    $(ROMFSINST) ./hello /bin/hello    *

.PHONY:clean
\end{verbatim}
带星号的两行代码目的是将编译生成的可执行文件拷贝到临时文件系统(romfs)中的bin目录下.
\item 为了让开发包在make过程中进入该文件夹读取Makefile,需要修改两个文件:user目录下的Konfig和Makefile.在Konfig中,添加如下代码:
\begin{verbatim}
menu "CF Application"

config CF_HELLO
    bool "cf hello application"
endmenu
\end{verbatim}
然后在Makefile中添加如下代码:
\begin{verbatim}
dir_$(CONFIG_CF_HELLO)            += hello
\end{verbatim}
\item 运行\fbox{make menuconfig}选择"Kernel/Library/Defaults Selection--->Customize Application/Library Settings"保存退出.进入
函数库和应用程序配置界面,此时界面上会多出一个选项"CF Application",进入后会看到"cf hello application"的二值选项.如图\ref{f_appcf}所示.
\begin{figure}[!bthp]
\centering
\includegraphics[width=0.7\textwidth]{pic/f_app_cf.eps}
\caption{添加的应用程序配置选项\label{f_appcf}}
\end{figure}
保存修改,退出.
\item 运行\fbox{make}命令生成内核镜像.下载镜像到开发板上,执行\fbox{hello}就会在与开发板相连终端看到打印信息.
\end{enumerate}
%%%%%%%%%%%%%%%%%%%%FTK简介及应用程序编写%%%%%%%%%%%%%%%
\setcounter{footnote}{0}
\newpage{}
\section{FTK简介及应用程序编写}
以下介绍内容的硬件平台是\textit{DE2-70}+\textit{TRDB\_LTM}.使用的工程是本文附带的"Nios2\_\-linux\_Total".

目前Altera的Nios处理器的速度还不尽人意,在CycloneII芯片上经过优化最大能达到的时钟频率是100Mhz\footnote{指的是带有大量外设的片上
系统,若只有一个CPU,外加SDRAM则可以优化到150Mhz.}.在这种情况下要想较流畅的运行图形应用程序,需要一个轻量级的图形库.另一个更加重要而且
现实的原因是,目前能找到的既有精美的外观又能移植到nios linux上的图形库,就只有FTK一个\footnote{MicroWindows就像古板的Windows98,界面
实在难以恭维.Qt Embedded目前无法移植,而Gtk+的嵌入式版本基本就是浮云}.本节通过构建系统,FTK安装,FTK应用程序编写以及在LTM上使用FTK这几个方面
介绍FTK.
%%%7.1
\subsection{构建带触摸屏和显示屏的系统}
%%%7.1.1
\subsubsection{硬件}
本文通篇使用的开发板都是友晶公司的\textit{DE2-70},触摸屏也选择了与之配套的\textit{TRDB\_LTM}.这是一块最大分辨率能达到800*480的电阻屏.
它通过扩展线与\textit{DE2-70}的GPIO 0扩展槽连接.与FPGA的接口有三部分:
\begin{itemize}
\item 显示屏的配置接口.它是一个SPI时序的串行接口,通过该接口对显示屏的分辨率等进行配置.
\item 显示屏显示所需信号线.包括RGB颜色数据,行场信号等.
\item 触摸屏输入信号,也是一个SPI接口,外加一根中断信号线,用于通知有触摸动作发生.而SPI接口则传输发生触摸点的X,Y坐标.
\end{itemize}
值得注意的是,两个SPI接口共享\textbf{时钟和使能}信号.

笔者使用以下几个部分管理LTM:
\begin{itemize}
\item ssram控制器和三态桥.ssram控制器用于直接和开发板上SSRAM芯片连接,三态桥负责CPU与ssram控制器通信.ssram作为图形显示界面的显示缓存.
\item pixel buffer大学计划IP.该IP负责从ssram中读取图像数据,扩展成固定的格式后通过流式接口传给VGA控制器.
该IP的参数设置如表\ref{pb_para}所示:
%\begin{table}[!h]

\begin{threeparttable}
\begin{tabular}{|l|l|}
\hline
DE Board & DE2-70 \\\hline
Video Out Device & Lcd Screen with Touch Panel(TRDB\_LTM)\\\hline
Default Buffer Start Address(hex) & 14000000\tnote{1}\\\hline
Default Back Buffer Start Address(hex) & 14000000\tnote{2}\\\hline
Addressing Mode & Consecutive\tnote{3}\\\hline
Width Scaling Factor & 2\\\hline
Height Scaling Factor & 2\\\hline
Color Space & 16-bit RGB\\\hline
\end{tabular}
\caption{Pixel Buffer参数设置\label{pb_para}}
\begin{tablenotes}
\item[1] 此处填写的是图形缓冲区首地址,pixel buffer将从该地址开始提取图像数据.这里填的是ssram首地址.
\item[2] pixel buffer支持双缓冲模式.由于FTK底层不支持,用不到该参数.
\item[3] pixel buffer支持两种数据读取模式,一种是按地址线性读取(Consecutive),一种是按图像坐标读取(X-Y).
\end{tablenotes}
\end{threeparttable}
%\end{table}
最后三个参数表明,原数据每一个像素点为2字节(RGB565格式),图像大小400*240.经过pixel buffer后硬扩为30-bit RGB大小为800*480的图像.
\item VGA控制器大学计划IP.该IP将接收到的数据按LTM显示屏所需的时序发送给LTM的显示部分.参数设置如表\ref{vc_para}所示:
\begin{table}[!h]
\centering
\begin{tabular}{|l|l|}
\hline
DE Board & DE2-70\\\hline
Video Out Device & Lcd Screen with Touch Panel(TRDB\_LTM)\\\hline
\end{tabular}
\caption{VGA Controller参数设置\label{vc_para}}
\end{table}
\item lcd\_spi\_controller.这是友晶公司演示例程中的一个SPI配置LTM模块.通过该模块上电时配置LTM.
\item spi外设和带中断功能的GPIO.通过SOPC系统库自带的SPI外设和通用IO口接收来自触摸屏的中断信号和坐标数据.
\end{itemize}
在进行系统构建时,要注意以下几个问题:
\begin{itemize}
\item 时钟一致性问题.VGA控制器,pixel buffer,ssram控制器以及ssram三态桥使用的时钟需一致,且必须是提供给LTM显示屏时钟的两倍.本系统设计时
采用一个锁相环(PLL提供50Mhz和25Mhz时钟).
\item LTM最大支持800*480,而FTK实际分辨率为400*240,最根本的原因是nios不给力,高分辨率情况下的窗口响应速度目测为秒级.严重拖慢系统性能.
\item 之前提过,两个SPI模块共用时钟和使能信号,而LTM配置信号只需要上电时使用,因此可以通过一行语句将复用的信号分开:
\begin{verbatim}
    assign adc_ltm_sclk	= ( adc_dclk & ltm_3wirebusy_n ) 
	|  ( ~ltm_3wirebusy_n & ltm_sclk );
\end{verbatim}
\item 显示设备不是平台设备,驱动由笔者自行编写,已存在于笔者提供的内核开发包中\footnote{本文附带文件夹中也有}.而触摸设备的驱动是内核开发包
支持的,因此需命名为\textbf{touch\_panel\_spi}和\textbf{touch\_panel\_pen\_irq\_n}.
\item 触摸屏所使用的SPI外设时钟为\textbf{1Khz},过高或过低都有工作异常的可能.
\item FTK本身支持键盘输入设备,可添加大学计划IP--PS2 Controller支持PS2键盘.
\end{itemize}
%%%7.1.2
\subsubsection{软件}
硬件编译完成后,需在内核中配置驱动支持.通过以下步骤开启显示设备驱动支持:
\begin{enumerate}
\item 若采用的是从官网下载的内核开发包.请用本文附带资料altfb.c替换driver/video/下同名文件.
\item 打开内核配置界面,进入"Device Drivers--->Graphics support--->",开启"Support for frame buffer devices--->"选项并进入其中,选中
"Altera framebuffer support".
\item 回到设备驱动主界面,开启SPI支持.
\item 进入"Input device support--->",开启"Mouse interface",将分辨率设为"800*480".开启"Event interface".使能
"Touchscreen--->ADS7846/TSC2046 and ADS7843 based touchscreens".
\item 经过以上设置后,nios linux运行时将以"/dev/fb0"文件形式管理显示屏,以"/dev/event/event0"文件形式管理触摸屏.
\end{enumerate}
在NiosWiki上对显示设备驱动的配置也有详细的介绍,只不过是针对默认的VGA显示设备.可以在配置时进行参考.
%%%7.2
\subsection{FTK介绍及安装}
FTK其实是funny toolkit的简写.它源自于深圳一位工程师的一本书<系统程序员成长计划>,是该书的综合项目.随着版本提升,逐渐变成一个相对完善的
嵌入式轻量级GUI.它具有如下特点:
\begin{itemize}
\item 核心部分足够小.运行时只占用几百KB内存空间\footnote{注意,虽然只是\textbf{核心}占用内存少,所有相关资源加起来也只要几十MB,依然很小}.
\item 全面的GUI组件支持.窗口,对话框,按钮,进度条等等.
\item 外观漂亮,支持自定义主题.这对于如此小型的图形库来说是难能可贵的.更加可贵的是,通过扩展文件,它支持拼音,五笔等中文输入法.
\item 多平台的支持.目前支持linux,windows以及uCos II.
\end{itemize}
目前FTK依然只是一个新生项目,笔者编写本文时,FTK才发布了0.5版.且将并入RT-Thread项目.有兴趣的同学可以参与该项目的
\href{https://groups.google.com/group/funnytoolkit}{讨论}\footnote{由于GFW的原因,需要翻墙访问},为国内开源
事业贡献一份力.

\textbf{在本文中,将使用0.4版本,这是笔者开发时使用的版本}.
%%%7.2.1
\subsubsection{PC机}
\begin{enumerate}
\item 从\href{http://code.google.com/p/ftk/downloads/list}{官网}或本文附带资料中拷贝ftk-0.4.tar.gz到虚拟机中.使用
\fbox{tar -zxvf ftk-0.4.tar.gz}解压缩.在ftk-0.4文件夹中,有一个README文档,其中简要介绍了如何安装ftk.在开始安装之前,需要先安装依赖函数库.
运行如下命令:
\begin{verse}
sudo apt-get install libx11-dev libxext-dev libjped-dev libpng12-dev
\end{verse}
\item 进入解压后的文件夹ftk-0.4,运行\fbox{./autogen.sh}\footnote{打开该脚本可以看到是由AutoTools工具编写的命令序列}生成configure脚本.
\item 运行configure脚本之前,需要对一些配置参数有一定的了解,见表\ref{ftk_cfg}:
\begin{table}[!bhtp]
\centering
\begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
\hline
--help & 显示所有配置参数.\\\hline
--prefix & 指定函数库相关资料的安装位置,包括函数库头文件和库文件安装目录等.\\\hline
--build & 指定软件包编译所在系统.\\\hline
--host & 指定可执行文件和库文件运行所在系统.\\\hline
--enable-shared & 生成共享函数库,默认开启.\\\hline
--enable-static & 生成静态函数库,默认开启.\\\hline
--enable-tslib & 通过tslib函数库使能触摸设备支持.默认不开启.在PC机上不必开启,而nios平台上必须开启.
这是nios平台进行屏幕操作的唯一途径.\\\hline
--enable-cairo & 使能cairo矢量图函数库支持.默认关闭.\\\hline
--enable-handwrite & 使能手写输入,目前只有框架,默认关闭.\\\hline
--with-backend & 这个参数设置在什么设备上如何显示GUI,有以下几个选项:
\begin{itemize}
\item linux-x11:WxH.在这个选项下,ftk将运行在X11上进行仿真.W,H分别定义GUI宽高.
\item linux-native.ftk运行在framebuffer设备下.这是默认选项,也是nios平台的唯一选项.
\item linux-vlcd.ftk运行在虚拟framebuffer下.
\item linux-dfb.ftk运行在DirectFB设备下.
\end{itemize}\\\hline
\end{tabular}
\caption{FTK configure参数\label{ftk_cfg}}
\end{table}
\item 综合考虑CPU速率和内存使用等方面的因素,在本工程硬件条件下,分辨率为400x240.因此在PC机上保持同样分辨率以达到同样的显示效果.
\item 运行如下命令:
\begin{verse}
mkdir -p /opt/ftk\_install \#将FTK安装在/opt/ftk\_intstall下\\
./configure --prefix=/opt/ftk\_install --with-backend=linux-x11:400x240 \#在ftk-0.4下运行\\
make\\
make install\\
\end{verse}
\item 编译完成后,生成的库文件在ftk-0.4/src/.libs/目录下.由于共享库不在标准路径中,运行ftk应用程序时将找不到库文件.可在$\sim$/.bashrc中添加
一行代码:
\begin{verse}
export LD\_LIBRARY\_PATH=<ftk安装目录>/src/.libs/
\end{verse}
运行\fbox{source $\sim$/.bashrc}即可.
\end{enumerate}
为了确认FTK已经安装成功,可进入ftk-0.4/src/demos/目录.运行其中的demo应用程序.图\ref{ftk_hi}显示了demo\_hello程序的运行界面.
\begin{figure}[!bthp]
\centering
\includegraphics{pic/f_ftk_hello.eps}
\caption{demo\_hello运行界面\label{ftk_hi}}
\end{figure}
%%%7.2.2
\subsubsection{nios平台}
nios平台FTK的安装并不是简单的将源代码放入libs文件夹就可以完成的.该平台与PC平台有很重要的差异:
\begin{itemize}
\item FTK支持png,jpeg和bmp三种图像格式.PC平台FTK默认使用PNG格式作为主题图片.而nios平台的png和jpeg编解码函数库无法使用,同时FTK的bmp解码
函数存在nios平台无法兼容的代码,需要修改.
\item FTK底层设备名称与nios平台有差异,需要修改.
\item PC机上使用鼠标对屏幕进行操作.而nios平台则通过触摸屏设备进行人机交互.需要nios平台下tslib的支持.
\item 基于FTK的应用程序,调入内存运行时都会先读入某个目录下的配置文件,包括主题等.这个目录的路径取决于ftk编译时存在的路径.
\end{itemize}
为解决以上问题.笔者修改了FTK的源代码.使其在nios平台下能完美运行.nios平台下的源码包见附带资料中的"ftk-0.4(NiosII Linux).rar".

同时,针对第四个问题.笔者选择将nios ftk安装在/opt目录下.将"ftk-0.4(NiosII Linux).rar"内的压缩包"ftk(放置在opt文件夹下).tar.gz"
解压缩到/opt下,同时将Makefile文件拷贝到/opt下.进入解压缩的源码包目录,运行以下命令:
\begin{verse}
make clean\\
make disclean\\
./autogen.sh\\
\end{verse}
这样,FTK就能够顺利地和内核开发包一起编译.
%%%7.3
\subsection{编写FTK应用程序}
进行FTK应用程序的开发需要对FTK提供的API函数有一个大概的了解.如果能对FTK的源码进行较为深入的研究,就能更好的理解API函数的参数含义,同时
为编写自定义Widget打下良好的基础\footnote{现有的控件有时并不能满足特定应用的需要,因此需要利用基本的Widget进行继承,扩展.
这就需要对源码的深入理解}.

FTK目前还是一个很新的开源项目.暂时不具备相关的编程技术文档,要了解FTK的API函数,就只有进入ftk/src文件夹一探究竟.FTK源码具有良好的编程风格,
是不可多得的学习资料.有兴趣的同学可以通过作者李先静老师的
\href{http://www.limodev.cn/blog/archives/category/ftk\%E5\%B5\%8C\%E5\%85\%A5\%E5\%BC\%8Fgui}{博客}了解更多.

在src文件夹中,每一个控件都有一个.c和对应的.h头文件.如描述按钮控件的"ftk\_button.c"和"ftk\_button.h".
"ftk\_typedef.h"是FTK基础数据结构和宏定义所在文件,如主题对应图形文件后缀名,实际触摸屏设备路径和名称等.每一个控件的用法在它的头文件中
都有对应的函数.表\ref{ftk_api}对常用控件的API函数做一个简单介绍:
\begin{table}[!bhtp]
\centering
\begin{tabular}{|p{0.4\textwidth}|p{0.5\textwidth}|}
\hline
ftk\_init(int argc,char* argv[]) & FTK初始化函数,初始化全局数据结构,读入配置文件等等.在应用程序中必须在其他API被调用前调用.且只能
被调用一次.\\\hline
ftk\_app\_window\_create & 创建一个窗口.FTK中,能够放置控件的基础控件有两个:窗口或者对话框.\\\hline
ftk\_widget\_width & 取得当前窗口/对话框的宽度.\\\hline
ftk\_widget\_height & 取得当前窗口/对话框的高度.\\\hline
ftk\_button\_create & 在(x,y)创建宽为width,高为height的按钮.\\\hline
ftk\_button\_set\_clicked\_listener & 设置按钮对应的触发函数.\\\hline
ftk\_widget\_set\_text & 设置控件的标题.\\\hline
ftk\_dialog\_create & 创建对话框.\\\hline
ftk\_entry\_create & 创建单行输入框.\\\hline
ftk\_entry\_get\_text & 获取当前输入框内文本.\\\hline
ftk\_entry\_set\_text & 设置输入框文本内容.\\\hline
ftk\_entry\_set\_input\_method & 设置输入框中使用的输入法.\\\hline
ftk\_entry\_insert\_text & 向输入框内插入文本.\\\hline
............ & ...........\\\hline
\end{tabular}
\caption{FTK部分API函数简介\label{ftk_api}}
\end{table}

进行FTK编程,通常包括两部分内容:
\begin{enumerate}
\item 调用ftk\_init进行初始化.调用API函数创建窗口,控件.设计控件的大小及摆放位置,如果有多个窗口或对话框,需逐层设计每个窗口或对话框的控件
界面.由于FTK没有GUI设计工具.只能通过编写代码进行界面的微调.这也是为什么PC分辨率要和nios平台一致的重要原因.关联按键等控件和响应函数.
\item 编程设计各种响应函数以及后台线程.
\end{enumerate}

我们以一个简单的例子说明FTK应用程序开发.建立文件夹.在文件夹中新建button.c和Makefile两个文件.在button.c中加入如下内容:
\begin{verbatim}
#include "ftk.h"
#define IDC_TEST_BUTTON 1000

/*弹出窗口对应的按钮个数类型*/
static const char* buttons1[] = {"Yes", NULL};
static const char* buttons2[] = {"Yes", "No", NULL};
static const char* buttons3[] = {"Yes", "No", "Cancel", NULL};

/*响应函数*/
static Ret button_quit_clicked(void* ctx, void* obj)
{
	ftk_quit();
	return RET_OK;
}
static Ret button_hide_clicked(void* ctx, void* obj)
{
	ftk_widget_show(ftk_widget_lookup(ctx, IDC_TEST_BUTTON), 0);
	return RET_OK;
}
static Ret button_show_clicked(void* ctx, void* obj)
{
	ftk_widget_show(ftk_widget_lookup(ctx, IDC_TEST_BUTTON), 1);
	return RET_OK;
}
static Ret button_default_clicked(void* ctx, void* obj)
{
	ftk_warning("Hi", "欢迎来到FTK的世界^_^", buttons2);
	return RET_OK;
}
int main(int argc, char* argv[])
{
	int width = 0;
	int height = 0;
	FtkWidget* win = NULL;
	FtkWidget* button = NULL;

	ftk_init(argc, argv);
	win = ftk_app_window_create();          \\创建基础控件--窗口
	width = ftk_widget_width(win); 
	height = ftk_widget_height(win);         \\获取窗口的有效宽度和高度
	
	width = width/3 - 10;
	button = ftk_button_create(win, 0, 30, width, 50); \\创建按钮
	ftk_widget_set_text(button, "show");               \\设置按钮上显示的文本
	ftk_button_set_clicked_listener(button, button_show_clicked, win);  \\关联这个按钮对应的响应函数

	button = ftk_button_create(win, width + 10, 30, width, 50);
	ftk_widget_set_text(button, "hide");
	ftk_button_set_clicked_listener(button, button_hide_clicked, win);
	
	button = ftk_button_create(win, 2*(width + 10), 30, width, 50);
	ftk_widget_set_text(button, "test hi");
	ftk_widget_set_id(button, IDC_TEST_BUTTON);
	ftk_button_set_clicked_listener(button, button_default_clicked, win);
	
	button = ftk_button_create(win, 10, 130, width, 50);
	ftk_widget_set_text(button, "hi");
	ftk_button_set_clicked_listener(button, button_default_clicked, win);
	
	button = ftk_button_create(win, 200 + 10, 130, width, 50);
	ftk_widget_set_text(button, "quit");
	ftk_button_set_clicked_listener(button, button_quit_clicked, win);
	ftk_window_set_focus(win, button);     \\将这个按钮作为默认激活按钮

	ftk_widget_set_text(win, "button demo");  \\设置整个窗口的名称
	ftk_widget_show_all(win, 1);              \\显示窗口及窗口上的控件
	ftk_widget_set_attr(win, FTK_ATTR_QUIT_WHEN_CLOSE);  \\设置窗口属性

	ftk_run();        \\FTK应用程序进入事件响应循环
	return 0;
}
\end{verbatim}
这个程序构建了一个窗口,在窗口上放置五个按钮,单击按钮"hide","test hi"按钮将隐藏.单击"show"则再一次出现.单击"test hi"或"hi"按钮将会弹出一个
对话框.单击"quit"退出.

为了让程序能正常编译,需要在Makefile中添加PC版FTK的共享库路径和头文件路径.同时添加nios平台FTK共享库和头文件支持.Makefile文件如下:
\begin{verbatim}
SRC=$(wildcard *.c)
OBJ=$(patsubst %.c,%.o,$(wildcard *.c))
BIN=hi
C_FLAG=-I/home/bearchen/Documents/FTK/ftk-0.4/src/
LD_FLAG=-L/home/bearchen/Documents/FTK/ftk-0.4/src/.libs/ -lftk

all:$(BIN)

$(BIN):$(OBJ)
	gcc -o $@ $^ $(LD_FLAG)

%.o:%.c 
	gcc -c -o $@ $< $(C_FLAG)

cross:
	nios2-linux-gnu-gcc -o $(BIN) $(SRC) -I/opt/ftk/src/  -L/opt/ftk/src/.libs/ -lftk  -lts  \
	-L/opt/NiosIILinux/nios2-linux/uClinux-dist/staging/usr/lib/

clean:
	rm *.o $(BIN)

.PHONY:clean
\end{verbatim}
添加完成后,运行make生成PC下可执行程序.运行\fbox{./hi},图\ref{ftk_button}展示运行效果.

我们在Makefile中添加了交叉编译的选项cross.
运行\fbox{make cross}时将会生成nios平台的可执行文件.由于当前工程没有加入内核开发包中.make cross能正常编译的前提是开发包中的图形库
被使能.进入uClinux-dist,打开\textbf{应用程序配置界面}.进入"Library Configuration--->",选中"Build tslib"和"FTK support".保存退出.运行make
进行内核编译,将nios平台的FTK函数库编译完成.
\begin{figure}[!bhtp]
\centering
\includegraphics{pic/f_ftk_button.eps}
\caption{应用程序运行效果\label{ftk_button}}
\end{figure}
%%%7.4
\subsection{在开发板上跑FTK应用程序}
与普通可执行程序一样,FTK应用程序也有两种工程形式,一种是上一小节介绍的独立工程方式,另一种则是放入到内核开发包中.建议开发时在PC机上做好
编码测试工作.待功能验证无误后放入开发包中.

要让FTK在LTM触摸屏上正常运行,需要做些准备工作.先介绍一下FTK能够运行所需的文件有哪些:
\begin{itemize}
\item unicode.fnt文件是FTK必须的字体文件.如果在指定目录中不存在该文件.FTK应用程序将会报错退出.
\item theme文件夹.这是FTK的主题文件夹.没有该文件夹,应用程序将一片空白.
\end{itemize}
这两个文件是FTK能够运行的最小配置.其他如ftk.cnf并非必须,若存在会改变ftk配置路径.

但是,仅有这两个文件是远远不够的!

\begin{enumerate}
\item unicode.fnt文件有几MB大小.放入RAM文件系统不太现实:\textit{DE2-70}的flash大小只有8MB,该文件加上已有的文件一定超出flash容量.
就算是调试状态通过USB-Blaster下载,由于速率的问题,很花时间.因此最有效的办法就是将这些配置文件放入SD卡中.这就要求内核开启SD卡支持.
\item LTM使用触摸屏作为输入设备.内核要开启触摸屏设备驱动.同时启用tslib函数库.触摸屏的原始数据有噪声且范围比400x240的分辨率大很多.
通过tslib能够尽量的降低噪声.而原始坐标到逻辑坐标的转换是通过/etc/pointercal文件完成.该文件又是通过内核在\textit{DE2-70}上运行时
使用"tscalibrate"命令得到的.为了避免每次下载内核运行都进行一次坐标校正.可将已经确认的pointercal文件也拷贝到SD卡当中.
\end{enumerate}

那么,下载运行后,谁来把这些文件拷贝到指定的位置呢?

在uClinux-dist/vendor/Altera/common/下有一个rc文件,这个文件是一个shell脚本.nios linux内核初始化完成后,将会执行该文件中的命令.我们可以
利用该文件拷贝我们需要的文件,启动指定的程序等.打开rc文件,可以看到类似如下内容:
\begin{verbatim}
hostname linux
mount -t proc proc /proc -o noexec,nosuid,nodev
mount -t sysfs sysfs /sys -o noexec,nosuid,nodev
mount -t devpts devpts /dev/pts -o noexec,nosuid
[ -d /proc/bus/usb ] && mount -t usbfs usbfs /proc/bus/usb
if [ -e /bin/mdev ] ; then
	mount -t tmpfs mdev /dev -o exec,nosuid,mode=0755,size=10M
	[ -e /proc/sys/kernel/hotplug ] && echo /bin/mdev > /proc/sys/kernel/hotplug
	/bin/mdev -s

	# some people want this (like to be verbose in their scripts?)
	ln -s /proc/self/fd /dev/fd
	ln -s fd/0 /dev/stdin
	ln -s fd/1 /dev/stdout
	ln -s fd/2 /dev/stderr
fi
mkdir /var/tmp
mkdir /var/log
mkdir /var/run
mkdir /var/lock
mkdir /var/empty
ifconfig lo 127.0.0.1
route add -net 127.0.0.0 netmask 255.0.0.0 lo
ifconfig eth0 172.20.47.118 netmask 255.255.255.0
mkdir /mnt/SD
mkdir /mnt/USB
mkdir -p /opt/ftk/data
mount /dev/mmcblk0p1 /mnt/SD
cat /etc/motd
TSLIB_FBDEVICE=/dev/fb0
TSLIB_CONSOLEDEVICE=none
TSLIB_CALIBFILE=/etc/pointercal
TSLIB_TSDEVICE=/dev/input/event0
cp /mnt/SD/Ftk_Makeup/pointercal /etc
cp -r /mnt/SD/Ftk_Makeup/theme /opt/ftk/
cp /mnt/SD/Ftk_Makeup/unicode.fnt /opt/ftk/data/
\end{verbatim}
可以看到在当前这个脚本文件中.挂载proc等文件系统,创建USB子系统,新建一些文件夹,配置网络,\textbf{创建SD,USB文件夹用来挂载这两种设备,
挂载SD卡,配置触摸屏设备参数,拷贝文件}.

现在,你所要做得事情是修改rc文件,重新编译内核,将FTK应用程序拷贝到SD卡中,插入\textit{DE2-70}.下载内核.进入SD卡运行程序.就会在LTM
上看到图形界面了.
%%%%%%%%%%%%%%%%%%%%结语%%%%%%%%%%%%%%%
\setcounter{footnote}{0}
\newpage{}
\section{结语}
\end{document}
